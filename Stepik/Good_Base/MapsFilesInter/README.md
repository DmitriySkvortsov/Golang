# map, файлы, интерфейсы

##

Внутри функции main необходимо написать программу:

На стандартный ввод подается 10 целых чисел, разделенных пробелами 
(числа могут повторяться). Для чтения из стандартного ввода импортирован пакет fmt.

Вам необходимо вычислить результат выполнения функции work для каждого из полученных чисел. 
Функция work имеет следующий вид:
```
func work(x int) int
```
Результаты вычислений , разделенные пробелами, должны быть напечатаны в строку.
Однако работа функции work занимает слишком много времени. 
Выделенного вам времени выполнения не хватит на последовательную обработку каждого числа, 
поэтому необходимо реализовать кэширование уже готовых результатов и использовать их в 
работе.

После завершения работы программы результат выполнения будет дополнен информацией о 
соблюдении установленного лимита времени выполнения.

Sample Input:
- 3 1 5 2 3 5 3 0 3 4
Sample Output:
- 2 0 6 1 2 6 2 -1 2 5 time limit ok

### Решение
#### 01_func_work


##

В ходе анализа результатов переписи населения информация была сохранена в объекте типа map:

```
groupCity := map[int][]string{
	10:   []string{...}, // города с населением 10-99 тыс. человек
	100:  []string{...}, // города с населением 100-999 тыс. человек
	1000: []string{...}, // города с населением 1000 тыс. человек и более
}
```

При подготовке важного отчета о городах с населением 100-999 тыс. человек был 
подготовлен другой объект типа map:
```
cityPopulation := map[string]int{
	город: население города в тысячах человек,
}
```
Однако база данных с информацией о точной численности населения содержала ошибки, 
поэтому в cityPopulation в т.ч. была сохранена информация о городах, которые входят 
в другие группы из groupCity.

Ваша программа имеет доступ к обоим указанным отображениям, требуется исправить 
cityPopulation, чтобы в ней была сохранена информация только о городах из 
группы groupCity[100].


### Решение
#### 02


## Convert

Напишите функцию с именем convert, которая конвертирует входное число типа int64 в uint16.

### Решение
#### 03_convert


## Joker

Представьте что вы работаете в большой компании где используется модульная архитектура. 
Ваш коллега написал модуль с какой-то логикой (вы не знаете) и передает в вашу программу 
какие-то данные. Вы же пишете функцию которая считывает две переменных типа string , 
а возвращает число типа int64 которое нужно получить сложением этих строк.


Но не было бы так все просто, ведь ваш коллега не пишет на Go, и он зол из-за того, 
что гоферам платят больше. Поэтому он решил подшутить над вами и подсунул вам свинью. 
Он придумал вставлять мусор в строки перед тем как вызывать вашу функцию.


Поэтому предварительно вам нужно убрать из них мусор и конвертировать в числа. 
Под мусором имеются ввиду лишние символы и спец знаки. 
Разрешается использовать только определенные пакеты: fmt, strconv, unicode, strings,  bytes. 

Sample Input:
- %^80 hhhhh20&&&&nd
Sample Output:
- 100

### Решение
#### 04_bad_joke


##

Для решения данной задачи вам понадобится пакет strconv, возможно использовать пакеты 
strings или encoding/csv, или даже bufio - вы не ограничены в выборе способа решения задачи. 

В привычных нам редакторах электронных таблиц присутствует удобное представление числа с 
разделителем разрядов в виде пробела, кроме того в России целая часть от дробной отделяется 
запятой. Набор таких чисел был экспортирован в формат CSV, где в качестве разделителя 
используется символ ";".

На стандартный ввод вы получаете 2 таких вещественных числа, в качестве результата требуется
вывести частное от деления первого числа на второе с точностью до четырех знаков после 
"запятой" (на самом деле после точки, результат не требуется приводить к исходному формату).

Sample Input:
- 1 149,6088607594936;1 179,0666666666666
Sample Output:
- 0.9750

### Решение
#### 05


##

Используем анонимные функции на практике.

Внутри функции main вы должны объявить функцию вида func(uint) uint, которую внутри функции main в дальнейшем можно будет вызвать по имени fn.

Функция на вход получает целое положительное число (uint), возвращает число того же типа в котором отсутствуют нечетные цифры и цифра 0. Если же получившееся число равно 0, то возвращается число 100. Цифры в возвращаемом числе имеют тот же порядок, что и в исходном числе.
"fmt" и "strconv", другие пакеты импортировать нельзя.

Sample Input:
- 727178
Sample Output:
- 28

### Решение
#### 06


##

Обязательные условия выполнения: данные со стандартного ввода читаются функцией readTask(),
которая возвращает 3 значения типа пустой интерфейс. 
Эта функция использует пакеты encoding/json, fmt, и os - не удаляйте их из импорта. 
Скорее всего, вам понадобится пакет "fmt", но вы можете использовать любой другой пакет для 
записи в стандартный вывод не удаляя fmt.

Итак, вы получаете 3 значения типа пустой интерфейс: если все удачно, то первые 2 значения
будут float64. Третье значение в идеальном случае будет строкой, которая может иметь 
значения: "+", "-", "*", "/" (определенная математическая операция). Но такие идеальные 
случаи будут не всегда, вы можете получить значения других типов, а также строка в третьем 
значении может не относится к одной из указанных математических операций.

Результат выполнения программы должен быть таков:

- в штатной ситуации вы должны напечатать в стандартный вывод результат выполнения 
математической операции с точностью до 4 цифры после запятой (fmt.Printf(%.4f));
- если первое или второе значение не является типом float64, вы должны напечатать сообщение 
об ошибке вида: value=полученное_значение: тип_значения (например: value=true: bool)
- если третье значение имеет неверный тип или передан знак, не относящийся к указанным выше
математическим операциям, сообщение об ошибке должно иметь вид: неизвестная операция

Гарантируется, что ошибка в аргументах может быть только одна, поэтому если вы при проверке
первого значения увидели, что оно содержит ошибку - печатайте сообщение об ошибке и 
завершайте работу программы, проверка остальных аргументов значения уже не имеет, а 
проверяющая система воспримет 2 сообщения об ошибке как нарушение условия выполнения задания.

### Решение
#### 07


## batery

Давайте используем ваши знания структур, методов и интерфейсов на практике и реализуем
объект, удовлетворяющий интерфейсу fmt.Stringer. Назовем его "Батарейка".

Во-первых, вы должны объявить новый тип, удовлетворяющий интерфейсу fmt.Stringer.

Ваш тип должен предусматривать, что на печати он будет выглядеть так: [      XXXX]: 
где пробелы - "опустошенная" емкость батареи, а X - "заряженная".

Во-вторых, на стандартный ввод вы получаете строку, состоящую ровно из 10 цифр: 0 или 1 
(порядок 0/1 случайный). Ваша задача считать эту строку любым возможным способом и создать 
на основе этой строки объект объявленного вами на первом этапе типа: надеюсь, вы понимаете, 
что строка символизирует емкость батарейки: 0 - это "опустошенная" часть, а 1 - "заряженная".

В-третьих, созданный вами объект должен называться batteryForTest 
(использование этого имени обязательно).

В вашем распоряжении фактически весь файл, НО завершающая фигурная скобка функции main() вам
не видна, но она присутствует. Перед этой скобкой присутствует функция (которая вам тоже не 
видна), принимающая в качестве аргумента объект типа fmt.Stringer - batteryForTest, и 
направляющая его на стандартный вывод, поэтому вам не требуется выводить что-то на печать 
самостоятельно.

Sample Input:
- 1000010011
Sample Output:
- [      XXXX]

### Решение
#### 08


## bufio vs fmt
Ранее в рамках этого курса при решении задач требовалось прочитать что-то со стандартного 
ввода и вывести результат соответственно в стандартный вывод. При этом кто-то использовал 
пакет fmt, а кто-то - bufio + os. Все эти пакеты имеют свои особенности, поэтому в этой 
задаче мы попробуем решить знакомую нам проблему с помощью пакетов, которые кто-то мог до 
этого момента и не применять: bufio + os + strconv.

Задача состоит в следующем: на стандартный ввод подаются целые числа в диапазоне 0-100, 
каждое число подается на стандартный ввод с новой строки (количество чисел не известно). 
Требуется прочитать все эти числа и вывести в стандартный вывод их сумму.

Несколько подсказок: для чтения вы можете использовать типы bufio.Reader и bufio.Scanner, 
а для записи - bufio.Writer. При чтении помните об ошибке io.EOF. 
Конвертирование данных из строки в целое число и обратно осуществляется функциями Atoi и 
Itoa из пакета strconv соответственно. Чтение производится из стандартного ввода (os.Stdin), 
а запись - в стандартный вывод (os.Stdout).

пакеты strconv, bufio, os, io (другие использовать нельзя).

Sample Input:
- 33
- 47
- 12
- 79
- 15
Sample Output:
- 186

### Решение
#### 09


## 

На стандартный ввод подаются данные о студентах университетской группы в формате JSON:
```
{
    "ID":134,
    "Number":"ИЛМ-1274",
    "Year":2,
    "Students":[
        {
            "LastName":"Вещий",
            "FirstName":"Лифон",
            "MiddleName":"Вениаминович",
            "Birthday":"4апреля1970года",
            "Address":"632432,г.Тобольск,ул.Киевская,дом6,квартира23",
            "Phone":"+7(948)709-47-24",
            "Rating":[1,2,3]
        },
        {
            // ...
        }
    ]
}
```
В сведениях о каждом студенте содержится информация о полученных им оценках (Rating). 
Требуется прочитать данные, и рассчитать среднее количество оценок, полученное студентами 
группы. Ответ на задачу требуется записать на стандартный вывод в формате JSON в следующей 
форме:
```
{
    "Average": 14.1
}
```
Как вы понимаете, для декодирования используется функция Unmarshal, а для кодирования 
MarshalIndent (префикс - пустая строка, отступ - 4 пробела).

### Решение
#### 10


## 

На стандартный ввод подается строковое представление даты и времени в следующем формате:
- 1986-04-16T05:20:00+06:00
Ваша задача конвертировать эту строку в Time, а затем вывести в формате UnixDate:
- Wed Apr 16 05:20:00 +0600 1986

### Решение
#### 11


## 

На стандартный ввод подается строковое представление даты и времени определенного события в 
следующем формате:
- 2020-05-15 08:00:00
Если время события до обеда (13-00), то ничего менять не нужно, достаточно вывести дату на 
стандартный вывод в том же формате.

Если же событие должно произойти после обеда, необходимо перенести его на то же время на 
следующий день, а затем вывести на стандартный вывод в том же формате.

### Решение
#### 12


## 

На стандартный ввод подается строковое представление двух дат, разделенных запятой 
(формат данных смотрите в примере).

Необходимо преобразовать полученные данные в тип Time, а затем вывести продолжительность 
периода между меньшей и большей датами.

Sample Input:
- 13.03.2018 14:00:15,12.03.2018 14:00:15
Sample Output:
- 24h0m0s

### Решение
#### 13


## 

На стандартный ввод подаются данные о продолжительности периода (формат приведен в примере).
Кроме того, вам дана дата в формате Unix-Time: 1589570165 в виде константы типа int64 
(наносекунды для целей преобразования равны 0).

Требуется считать данные о продолжительности периода, преобразовать их в тип Duration, а 
затем вывести (в формате UnixDate) дату и время, получившиеся при добавлении периода к 
стандартной дате.

Небольшая подсказка: базовую дату необходимо явно перенести в зону UTC с помощью 
одноименного метода.

Sample Input:
- 12 мин. 13 сек.
Sample Output:
- Fri May 15 19:28:18 UTC 2020

### Решение
#### 14


## 

Напишите функцию которая принимает канал и число N типа int. 
Необходимо вернуть значение N+1 в канал. 
Функция должна называться task().

### Решение
#### 15_func_task


## 

Напишите функцию которая принимает канал и строку. 
Необходимо отправить эту же строку в заданный канал 5 раз, добавив к ней пробел.

Функция должна называться task2().

### Решение
#### 16_func_task2


## 

Напишите элемент конвейера (функцию), что запоминает предыдущее значение и отправляет 
значения на следующий этап конвейера только если оно отличается от того, что пришло ранее.

Ваша функция должна принимать два канала - inputStream и outputStream, в первый вы будете 
получать строки, во второй вы должны отправлять значения без повторов. В итоге в 
outputStream должны остаться значения, которые не повторяются подряд. Не забудьте закрыть
канал 

Функция должна называться removeDuplicates()

### Решение
#### 17


## 

Внутри функции main (функцию объявлять не нужно), вам необходимо в отдельной горутине 
вызвать функцию work() и дождаться результатов ее выполнения. 

Функция work() ничего не принимает и не возвращает.

### Решение
#### 18


## 

Внутри функции main  вам необходимо в отдельных горутинах вызвать функцию work() 10 раз и 
дождаться результатов выполнения вызванных функций.
 
Функция work() ничего не принимает и не возвращает.

### Решение
#### 19


## 

Вам необходимо написать функцию calculator следующего вида:
```
func calculator(firstChan <-chan int, secondChan <-chan int, stopChan <-chan struct{}) <-chan int
```

Функция получает в качестве аргументов 3 канала, и возвращает канал типа <-chan int.

- в случае, если аргумент будет получен из канала firstChan, 
в выходной (возвращенный) канал вы должны отправить квадрат аргумента.

- в случае, если аргумент будет получен из канала secondChan, в выходной (возвращенный) 
канал вы должны отправить результат умножения аргумента на 3.

- в случае, если аргумент будет получен из канала stopChan, нужно просто завершить работу 
функции.

Функция calculator должна быть неблокирующей, сразу возвращая управление. 
Ваша функция получит всего одно значение в один из каналов - получили значение, 
обработали его, завершили работу.

После завершения работы необходимо освободить ресурсы, закрыв выходной канал, 
если вы этого не сделаете, то превысите предельное время работы.

### Решение
#### 20


##

Вам необходимо написать функцию calculator следующего вида:
```
func calculator(arguments <-chan int, done <-chan struct{}) <-chan int
```
В качестве аргумента эта функция получает два канала только для чтения, 
возвращает канал только для чтения.

Через канал arguments функция получит ряд чисел, а через канал done - сигнал о 
необходимости завершить работу. Когда сигнал о завершении работы будет получен, 
функция должна в выходной (возвращенный) канал отправить сумму полученных чисел.

Функция calculator должна быть неблокирующей, сразу возвращая управление.

Выходной канал должен быть закрыт после выполнения всех оговоренных условий, 
если вы этого не сделаете, то превысите предельное время работы.

### Решение
#### 21


##

Необходимо написать функцию func merge2Channels(fn func(int) int, in1 <-chan int, in2 <- chan int, out chan<- int, n int).

Описание ее работы:

n раз сделать следующее

прочитать по одному числу из каждого из двух каналов in1 и in2, назовем их x1 и x2.
вычислить f(x1) + f(x2)
записать полученное значение в out
Функция merge2Channels должна быть неблокирующей, сразу возвращая управление.

Функция fn может работать долгое время, ожидая чего-либо или производя вычисления.

Формат ввода:
- количество итераций передается через аргумент n.
- целые числа подаются через аргументы-каналы in1 и in2.
- функция для обработки чисел перед сложением передается через аргумент fn.
Формат вывода:
- канал для вывода результатов передается через аргумент out.

### Решение
#### 22
